<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Game of Life</title>
  <style>
    :root{
      --bg:#0b0e14; /* deep navy */
      --panel:#121723;
      --ink:#e8e9ee; /* ivory */
      --muted:#a9afc3;
      --accent:#e2b714; /* gold */
      --live:#e8e9ee;  /* live cell color */
      --dead:#0b0e14;  /* dead cell color */
      --grid:#202735;
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"}
    .app{display:grid;grid-template-rows:auto 1fr auto;height:100vh;}
    header{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;padding:10px 14px;background:var(--panel);position:sticky;top:0;border-bottom:1px solid #1b2130}
    header h1{font-size:16px;margin:0 8px 0 0;letter-spacing:.3px}
    header .hint{color:var(--muted);font-size:12px}

    .controls{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;margin-left:auto}
    .controls > *{margin:0}

    button, select, input[type="number"], input[type="text"]{background:#1a2232;color:var(--ink);border:1px solid #2a3347;border-radius:10px;padding:8px 10px}
    button{cursor:pointer}
    button.primary{background:var(--accent);color:#0b0e14;border-color:#aa8a10}
    button.tiny{padding:6px 8px;font-size:12px}
    label{display:flex;align-items:center;gap:.4rem;color:var(--muted)}
    input[type="range"]{accent-color:var(--accent)}
    .sep{width:1px;height:28px;background:#20283a;margin:0 6px}

    .stage{position:relative;display:grid;grid-template-columns:1fr 260px;gap:8px;padding:8px;height:100%;}
    .stage canvas{width:100%;height:100%;background:var(--dead);border-radius:12px;box-shadow:0 0 0 1px #1b2130 inset}
    .sidebar{background:var(--panel);border-left:1px solid #1b2130;border-radius:12px;padding:10px;overflow:auto}

    .row{display:flex;gap:.5rem;align-items:center;margin:8px 0;flex-wrap:wrap}
    .row .grow{flex:1}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;background:#0f1420;border:1px solid #1f2740;color:#e8e9ee;border-radius:6px;padding:1px 6px;font-size:12px}

    footer{padding:8px 12px;color:var(--muted);border-top:1px solid #1b2130;background:var(--panel)}
    a{color:var(--accent)}
    @media (max-width: 900px){
      .stage{grid-template-columns:1fr}
      .sidebar{order:-1}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Conway's Game of Life</h1>
      <div class="hint">click to toggle • drag to draw • <span class="kbd">Shift</span> to erase</div>
      <div class="controls">
        <button id="play" class="primary" title="Space">▶ Play</button>
        <button id="step" title="S">Step</button>
        <button id="clear" title="C">Clear</button>
        <button id="random" title="R">Random</button>
        <span class="sep"></span>
        <label>Speed <input id="speed" type="range" min="1" max="60" value="12"/></label>
        <label>Cell <input id="cellSize" type="range" min="5" max="30" value="12"/></label>
        <label><input id="wrap" type="checkbox" checked/> Wrap</label>
        <label><input id="gridlines" type="checkbox" checked/> Grid</label>
      </div>
    </header>

    <div class="stage">
      <canvas id="board" aria-label="Game of Life board" role="img"></canvas>
      <aside class="sidebar">
        <h3 style="margin:6px 0 10px 0">Patterns</h3>
        <div class="row">
          <select id="pattern">
            <option value="">— choose —</option>
            <option value="glider">Glider</option>
            <option value="lwss">Lightweight Spaceship</option>
            <option value="smallExploder">Small Exploder</option>
            <option value="10cellRow">10‑Cell Row</option>
            <option value="gosper">Gosper Glider Gun</option>
          </select>
          <button id="insert" class="tiny">Insert at center</button>
        </div>
        <div class="row">
          <button id="save" class="tiny">Save</button>
          <button id="load" class="tiny">Load</button>
          <button id="exportJson" class="tiny">Export</button>
          <input id="importJson" type="file" accept="application/json" style="display:none"/>
          <button id="importBtn" class="tiny">Import</button>
        </div>
        <div class="row">
          <label>Brush <input id="brush" type="range" min="1" max="5" value="1"/></label>
          <label><input id="eraseToggle" type="checkbox"/> Erase mode</label>
        </div>
        <details open>
          <summary>Shortcuts</summary>
          <ul style="margin:8px 0 0 16px; padding:0 0 0 8px; line-height:1.8">
            <li><span class="kbd">Space</span> Play/Pause</li>
            <li><span class="kbd">S</span> Step once</li>
            <li><span class="kbd">R</span> Randomize</li>
            <li><span class="kbd">C</span> Clear</li>
            <li><span class="kbd">G</span> Toggle grid</li>
            <li><span class="kbd">W</span> Toggle wrap</li>
            <li>Drag to draw, hold <span class="kbd">Shift</span> to erase</li>
          </ul>
        </details>
        <details>
          <summary>Built‑in Tests</summary>
          <div class="row">
            <button id="runTests" class="tiny">Run tests</button>
          </div>
          <pre id="testOut" style="background:#0f1420;border:1px solid #1f2740;border-radius:8px;padding:8px;white-space:pre-wrap;max-height:200px;overflow:auto;color:var(--ink)"></pre>
        </details>
        <p style="color:var(--muted);margin-top:14px">Rules (B3/S23): a dead cell with exactly 3 live neighbors is born; a live cell survives with 2 or 3 neighbors.</p>
      </aside>
    </div>

    <footer>
      Built for learning & fun. Tip: try inserting the Gosper Glider Gun, then press Play.
    </footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const playBtn = document.getElementById('play');
  const stepBtn = document.getElementById('step');
  const clearBtn = document.getElementById('clear');
  const randomBtn = document.getElementById('random');
  const speedInput = document.getElementById('speed');
  const cellSizeInput = document.getElementById('cellSize');
  const wrapInput = document.getElementById('wrap');
  const gridlinesInput = document.getElementById('gridlines');
  const patternSel = document.getElementById('pattern');
  const insertBtn = document.getElementById('insert');
  const saveBtn = document.getElementById('save');
  const loadBtn = document.getElementById('load');
  const exportBtn = document.getElementById('exportJson');
  const importBtn = document.getElementById('importBtn');
  const importInput = document.getElementById('importJson');
  const brushInput = document.getElementById('brush');
  const eraseToggle = document.getElementById('eraseToggle');
  const runTestsBtn = document.getElementById('runTests');
  const testOut = document.getElementById('testOut');

  // *** FIX: define getCSS() used for CSS variable lookups ***
  function getCSS(variable) {
    return getComputedStyle(document.documentElement).getPropertyValue(variable).trim();
  }

  // World state
  let cellSize = parseInt(cellSizeInput.value, 10);
  let cols = 80, rows = 50; // initial logical grid size (will adapt)
  let grid = createGrid(cols, rows);
  let nextGrid = createGrid(cols, rows);
  let running = false;
  let lastTime = 0, acc = 0;

  // Resize canvas to device pixels to keep it crisp
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    // Fit logical size to current cell size & container
    const rect = canvas.getBoundingClientRect();
    cols = Math.max(5, Math.floor(rect.width / cellSize));
    rows = Math.max(5, Math.floor(rect.height / cellSize));

    const w = cols * cellSize;
    const h = rows * cellSize;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // If current grid differs in size, center-copy into new grid
    if (grid.length !== rows || grid[0].length !== cols) {
      const newGrid = createGrid(cols, rows);
      const yOff = Math.floor((rows - grid.length) / 2);
      const xOff = Math.floor((cols - grid[0].length) / 2);
      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
          const yy = y + yOff, xx = x + xOff;
          if (yy>=0 && yy<rows && xx>=0 && xx<cols) newGrid[yy][xx] = grid[y][x];
        }
      }
      grid = newGrid;
      nextGrid = createGrid(cols, rows);
    }
    draw();
  }

  function createGrid(cols, rows) {
    return Array.from({length: rows}, () => new Array(cols).fill(0));
  }

  function draw() {
    ctx.fillStyle = getCSS('--dead');
    ctx.fillRect(0, 0, cols * cellSize, rows * cellSize);

    // live cells
    ctx.fillStyle = getCSS('--live');
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (grid[y][x]) ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
      }
    }

    if (gridlinesInput.checked && cellSize >= 9) {
      ctx.strokeStyle = getCSS('--grid');
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x <= cols; x++) {
        ctx.moveTo(x*cellSize + .5, 0);
        ctx.lineTo(x*cellSize + .5, rows*cellSize);
      }
      for (let y = 0; y <= rows; y++) {
        ctx.moveTo(0, y*cellSize + .5);
        ctx.lineTo(cols*cellSize, y*cellSize + .5);
      }
      ctx.stroke();
    }
  }

  function step() {
    const wrap = wrapInput.checked;
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        let n = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (!dx && !dy) continue;
            let nx = x + dx, ny = y + dy;
            if (wrap) {
              nx = (nx + cols) % cols;
              ny = (ny + rows) % rows;
            }
            if (nx>=0 && nx<cols && ny>=0 && ny<rows) n += grid[ny][nx];
          }
        }
        const alive = grid[y][x] === 1;
        nextGrid[y][x] = (alive && (n===2 || n===3)) || (!alive && n===3) ? 1 : 0;
      }
    }
    // swap
    [grid, nextGrid] = [nextGrid, grid];
  }

  function loop(ts) {
    if (!running) return;
    const fps = parseInt(speedInput.value, 10); // generations per second
    const dt = ts - lastTime; lastTime = ts; acc += dt;
    const interval = 1000 / fps;
    while (acc >= interval) {
      step();
      acc -= interval;
    }
    draw();
    requestAnimationFrame(loop);
  }

  function togglePlay(force) {
    const next = force !== undefined ? force : !running;
    running = next;
    playBtn.textContent = running ? '⏸ Pause' : '▶ Play';
    playBtn.classList.toggle('primary', running);
    if (running) { lastTime = performance.now(); acc = 0; requestAnimationFrame(loop); }
  }

  // Mouse interaction
  let drawing = false;
  function canvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((evt.clientX - rect.left) / cellSize);
    const y = Math.floor((evt.clientY - rect.top) / cellSize);
    return {x,y};
  }
  function paintAt(x, y, erase) {
    const brush = parseInt(brushInput.value,10);
    for (let yy = y - (brush-1); yy <= y + (brush-1); yy++) {
      for (let xx = x - (brush-1); xx <= x + (brush-1); xx++) {
        if (xx>=0 && xx<cols && yy>=0 && yy<rows) grid[yy][xx] = erase ? 0 : 1;
      }
    }
  }
  canvas.addEventListener('mousedown', (e) => {
    const {x,y} = canvasPos(e);
    const erase = e.shiftKey || eraseToggle.checked || (grid[y] && grid[y][x]===1 && e.button===0 && e.metaKey);
    drawing = true;
    paintAt(x,y,erase);
    draw();
  });
  window.addEventListener('mouseup', () => drawing = false);
  canvas.addEventListener('mousemove', (e) => {
    if (!drawing) return;
    const {x,y} = canvasPos(e);
    paintAt(x,y, e.shiftKey || eraseToggle.checked);
    draw();
  });
  canvas.addEventListener('click', (e) => {
    // simple toggle on click when not dragging
    const {x,y} = canvasPos(e);
    if (x>=0 && x<cols && y>=0 && y<rows){ grid[y][x] = grid[y][x] ? 0 : 1; draw(); }
  });

  // Controls
  playBtn.addEventListener('click', () => togglePlay());
  stepBtn.addEventListener('click', () => { if (!running) { step(); draw(); }});
  clearBtn.addEventListener('click', () => { grid = createGrid(cols, rows); draw(); });
  randomBtn.addEventListener('click', () => {
    const density = 0.25; // could make UI later
    for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) grid[y][x] = Math.random() < density ? 1 : 0;
    draw();
  });
  speedInput.addEventListener('input', () => {/* handled in loop */});
  cellSizeInput.addEventListener('input', () => { cellSize = parseInt(cellSizeInput.value,10); resizeCanvas(); });
  gridlinesInput.addEventListener('change', draw);
  wrapInput.addEventListener('change', draw);

  // Patterns
  const PATTERNS = {
    glider: [ [1,0],[2,1],[0,2],[1,2],[2,2] ],
    lwss: [ [1,0],[4,0],[0,1],[0,2],[4,2],[0,3],[1,3],[2,3],[3,3] ],
    smallExploder: [ [0,1],[1,0],[1,1],[1,2],[2,0],[2,2],[3,1] ],
    tenCellRow: Array.from({length:10}, (_,i)=>[i,0]),
    gosper: (function(){
      // Gosper Glider Gun (36x9) pattern relative coords
      const r = [];
      const on = (...pts) => pts.forEach(([x,y]) => r.push([x,y]));
      on([24,0],[22,1],[24,1],[12,2],[13,2],[20,2],[21,2],[34,2],[35,2],[11,3],[15,3],[20,3],[21,3],[34,3],[35,3],[0,4],[1,4],[10,4],[16,4],[20,4],[21,4],[0,5],[1,5],[10,5],[14,5],[16,5],[17,5],[22,5],[24,5],[10,6],[16,6],[24,6],[11,7],[15,7],[12,8],[13,8]);
      return r;
    })()
  };

  insertBtn.addEventListener('click', () => {
    const key = patternSel.value;
    if (!key) return;
    const pts = key === '10cellRow' ? PATTERNS.tenCellRow : PATTERNS[key];
    const w = Math.max(...pts.map(p=>p[0])) + 1;
    const h = Math.max(...pts.map(p=>p[1])) + 1;
    const offX = Math.floor((cols - w)/2);
    const offY = Math.floor((rows - h)/2);
    for (const [dx,dy] of pts) {
      const x = offX + dx, y = offY + dy;
      if (x>=0 && x<cols && y>=0 && y<rows) grid[y][x] = 1;
    }
    draw();
  });

  // Save / Load / Import / Export
  const STORAGE_KEY = 'life-state-v1';
  saveBtn.addEventListener('click', () => {
    const data = {cols, rows, cellSize, wrap: wrapInput.checked, grid};
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    flash(playBtn, 'Saved');
  });
  loadBtn.addEventListener('click', () => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return alert('Nothing saved yet.');
    try{
      const data = JSON.parse(raw);
      cellSize = data.cellSize || cellSize;
      cellSizeInput.value = cellSize;
      wrapInput.checked = !!data.wrap;
      grid = data.grid && data.grid.length ? data.grid : grid;
      nextGrid = createGrid(grid[0].length, grid.length);
      resizeCanvas();
    }catch(e){ alert('Failed to load.'); }
  });
  exportBtn.addEventListener('click', () => {
    const data = {cols, rows, cellSize, wrap: wrapInput.checked, grid};
    const blob = new Blob([JSON.stringify(data)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'game-of-life.json'; a.click();
    URL.revokeObjectURL(url);
  });
  importBtn.addEventListener('click', () => importInput.click());
  importInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const text = await file.text();
    try{
      const data = JSON.parse(text);
      cellSize = data.cellSize || cellSize; cellSizeInput.value = cellSize;
      wrapInput.checked = !!data.wrap;
      grid = data.grid && data.grid.length ? data.grid : grid;
      nextGrid = createGrid(grid[0].length, grid.length);
      resizeCanvas();
    }catch(err){ alert('Invalid JSON'); }
    importInput.value = '';
  });

  function flash(el, msg){
    const old = el.textContent; el.textContent = msg; setTimeout(()=> el.textContent = old, 800);
  }

  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.target && ['INPUT','SELECT','TEXTAREA'].includes(e.target.tagName)) return;
    if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
    else if (e.key.toLowerCase() === 's') { if (!running) { step(); draw(); } }
    else if (e.key.toLowerCase() === 'r') { randomBtn.click(); }
    else if (e.key.toLowerCase() === 'c') { clearBtn.click(); }
    else if (e.key.toLowerCase() === 'g') { gridlinesInput.checked = !gridlinesInput.checked; draw(); }
    else if (e.key.toLowerCase() === 'w') { wrapInput.checked = !wrapInput.checked; draw(); }
  });

  // -------------------------------------------------------------
  // Pure helpers & built-in tests (do not affect interactive board)
  // -------------------------------------------------------------
  function emptyGrid(w,h){ return Array.from({length:h}, ()=> Array(w).fill(0)); }

  function computeNext(src, wrap=false){
    const h = src.length, w = src[0].length;
    const out = emptyGrid(w,h);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        let n=0;
        for (let dy=-1;dy<=1;dy++){
          for (let dx=-1;dx<=1;dx++){
            if(!dx && !dy) continue;
            let nx=x+dx, ny=y+dy;
            if (wrap){ nx=(nx+w)%w; ny=(ny+h)%h; }
            if (nx>=0 && nx<w && ny>=0 && ny<h) n += src[ny][nx];
          }
        }
        const alive = src[y][x]===1;
        out[y][x] = (alive && (n===2||n===3)) || (!alive && n===3) ? 1:0;
      }
    }
    return out;
  }

  function makeGrid(w,h, liveCoords){
    const g = emptyGrid(w,h);
    for (const [x,y] of liveCoords) if (y>=0&&y<h&&x>=0&&x<w) g[y][x]=1;
    return g;
  }
  function equalGrids(a,b){
    if (a.length!==b.length || a[0].length!==b[0].length) return false;
    for (let y=0;y<a.length;y++) for (let x=0;x<a[0].length;x++) if (a[y][x]!==b[y][x]) return false;
    return true;
  }
  function listLive(g){
    const pts=[]; for (let y=0;y<g.length;y++) for (let x=0;x<g[0].length;x++) if (g[y][x]) pts.push([x,y]);
    return pts.sort((p,q)=> p[1]-q[1] || p[0]-q[0]);
  }

  function runAllTests(){
    const results=[];

    // Test 1: Still life (block) remains unchanged after 1 generation
    (function(){
      const init = makeGrid(6,6, [[1,1],[2,1],[1,2],[2,2]]);
      const next = computeNext(init,false);
      const pass = equalGrids(init,next);
      results.push({name:'Still life: block', pass, details: pass?'OK':`Expected unchanged, got ${JSON.stringify(listLive(next))}`});
    })();

    // Test 2: Oscillator (blinker) flips orientation after 1 generation
    (function(){
      const init = makeGrid(6,6, [[1,2],[2,2],[3,2]]);
      const expected = makeGrid(6,6, [[2,1],[2,2],[2,3]]);
      const next = computeNext(init,false);
      const pass = equalGrids(expected,next);
      results.push({name:'Oscillator: blinker', pass, details: pass?'OK':`Expected vertical at (2,1..3), got ${JSON.stringify(listLive(next))}`});
    })();

    // Test 3: Glider translates (after 4 steps moves down-right by 1)
    (function(){
      const seed = [[1,0],[2,1],[0,2],[1,2],[2,2]]; // classic glider
      let g = makeGrid(10,10, seed);
      for (let i=0;i<4;i++) g = computeNext(g,false);
      const shifted = seed.map(([x,y])=>[x+1,y+1]);
      const expected = makeGrid(10,10, shifted);
      const pass = equalGrids(expected,g);
      results.push({name:'Spaceship: glider (4 steps shift)', pass, details: pass?'OK':`Expected ${JSON.stringify(shifted)}, got ${JSON.stringify(listLive(g))}`});
    })();

    return results;
  }

  function renderTestResults(items){
    if (!testOut) return;
    const lines = items.map((r,i)=> `${r.pass?'✅':'❌'} Test ${i+1}: ${r.name} — ${r.details}`);
    testOut.textContent = lines.join('\n');
  }

  if (runTestsBtn){
    runTestsBtn.addEventListener('click', () => {
      const results = runAllTests();
      renderTestResults(results);
      console.log('[Game of Life] Test results:', results);
    });
    // auto-run once on load for quick sanity
    const results = runAllTests();
    renderTestResults(results);
    console.log('[Game of Life] Test results:', results);
  }
  // -------------------------------------------------------------

  // Initial layout & observers
  const ro = new ResizeObserver(resizeCanvas);
  ro.observe(canvas);
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  draw();
})();
</script>
</body>
</html>
